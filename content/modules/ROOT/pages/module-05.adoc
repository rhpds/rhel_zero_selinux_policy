== Check for the AVC denials

Our service app is up and running, SELinux is in enforcing mode, but in
the policy is hard coded to allow our application to run in Permissive
mode. The system does not stop _testapp_ from accessing any requested
objects, but it logs all the SELinux policy violations in
/var/log/audit/audit.log

To start modifying our policy to allow the actions required by our
application we will look in the audit log for messages of type AVC that
happened today. We use the *ausearch* command.

[source,bash]
----
sudo ausearch --message AVC --start today
----

Wow! There are quite a few denials!

'''''

time->Sun Oct 30 22:07:18 2022 type=PROCTITLE
msg=audit(1667167638.686:2321): proctitle="`/usr/local/sbin/testapp`"
type=PATH msg=audit(1667167638.686:2321): item=3 name=(null) inode=1510
dev=00:19 mode=0100644 ouid=0 ogid=0 rdev=00:00
obj=system_u:object_r:var_run_t:s0 nametype=CREATE cap_fp=0 cap_fi=0
cap_fe=0 cap_fver=0 cap_frootid=0 type=PATH
msg=audit(1667167638.686:2321): item=2 name=(null) inode=1 dev=00:19
mode=040755 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:var_run_t:s0
nametype=PARENT cap_fp=0 cap_fi=0 cap_fe=0 cap_fver=0 cap_frootid=0
type=PATH msg=audit(1667167638.686:2321): item=1 name=(null)
nametype=CREATE cap_fp=0 cap_fi=0 cap_fe=0 cap_fver=0 cap_frootid=0
type=PATH msg=audit(1667167638.686:2321): item=0 name=(null) inode=1
dev=00:19 mode=040755 ouid=0 ogid=0 rdev=00:00
obj=system_u:object_r:var_run_t:s0 nametype=PARENT cap_fp=0 cap_fi=0
cap_fe=0 cap_fver=0 cap_frootid=0 type=CWD
msg=audit(1667167638.686:2321): cwd="`/`" type=SYSCALL
msg=audit(1667167638.686:2321): arch=c000003e syscall=257 success=yes
exit=3 a0=ffffff9c a1=101b750 a2=241 a3=1b6 items=4 ppid=1 pid=149921
auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0
tty=(none) ses=4294967295 comm="`testapp`"
exe="`/usr/local/sbin/testapp`" subj=system_u:system_r:testapp_t:s0
key=(null) … A long, long list…

....

Let's just focus in in the first AVC message. To do this we can use the filter from the ausearch command to retrieve just one entry, the first one, from the desired timeframe. The ausearch command takes a time in format *hh:mm:ss*, or reference (today | recent) for the *--start* argument.

```bash
ausearch --message AVC --just-one --start recent
....

____
*IMPORTANT* Use the command _'`date +%T`'_ to print a time to the screen
*right after* you restart the testapp and substitute that in your
*ausearch –start* command. Remember that _recent_ means in the last 10
minutes and _today_ means after 00:00:00 on the system clock. You want
to be sure that you are only looking at logs generated since the last
restart of your application. *–just-one* returns the first AVC that
occurs after the time specified by start.
____

We can pull this all into one line using bash.

[source,bash]
----
TIME=`date +%T`;export TIME; sudo systemctl restart testapp; sudo ausearch --message AVC --just-one --start $TIME
----

'''''

time->Tue Nov 1 03:36:46 2022 type=PROCTITLE
msg=audit(1667273806.737:3034): proctitle="`/usr/local/sbin/testapp`"
type=PATH msg=audit(1667273806.737:3034): item=3 name=(null) inode=2082
dev=00:19 mode=0100644 ouid=0 ogid=0 rdev=00:00
obj=system_u:object_r:var_run_t:s0 nametype=CREATE cap_fp=0 cap_fi=0
cap_fe=0 cap_fver=0 cap_frootid=0 type=PATH
msg=audit(1667273806.737:3034): item=2 name=(null) inode=1 dev=00:19
mode=040755 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:var_run_t:s0
nametype=PARENT cap_fp=0 cap_fi=0 cap_fe=0 cap_fver=0 cap_frootid=0
type=PATH msg=audit(1667273806.737:3034): item=1 name=(null)
nametype=CREATE cap_fp=0 cap_fi=0 cap_fe=0 cap_fver=0 cap_frootid=0
type=PATH msg=audit(1667273806.737:3034): item=0 name=(null) inode=1
dev=00:19 mode=040755 ouid=0 ogid=0 rdev=00:00
obj=system_u:object_r:var_run_t:s0 nametype=PARENT cap_fp=0 cap_fi=0
cap_fe=0 cap_fver=0 cap_frootid=0 type=CWD
msg=audit(1667273806.737:3034): cwd="`/`" type=SYSCALL
msg=audit(1667273806.737:3034): arch=c000003e syscall=257 success=yes
exit=3 a0=ffffff9c a1=a76750 a2=241 a3=1b6 items=4 ppid=1 pid=153704
auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0
tty=(none) ses=4294967295 comm="`testapp`"
exe="`/usr/local/sbin/testapp`" subj=system_u:system_r:testapp_t:s0
key=(null) type=AVC msg=audit(1667273806.737:3034): avc: denied \{ write
open } for pid=153704 comm="`testapp`" path="`/run/testapp.pid`"
dev="`tmpfs`" ino=2082 scontext=system_u:system_r:testapp_t:s0
tcontext=system_u:object_r:var_run_t:s0 tclass=file permissive=1
type=AVC msg=audit(1667273806.737:3034): avc: denied \{ create } for
pid=153704 comm="`testapp`" name="`testapp.pid`"
scontext=system_u:system_r:testapp_t:s0
tcontext=system_u:object_r:var_run_t:s0 tclass=file permissive=1
type=AVC msg=audit(1667273806.737:3034): avc: denied \{ add_name } for
pid=153704 comm="`testapp`" name="`testapp.pid`"
scontext=system_u:system_r:testapp_t:s0
tcontext=system_u:object_r:var_run_t:s0 tclass=dir permissive=1 type=AVC
msg=audit(1667273806.737:3034): avc: denied \{ write } for pid=153704
comm="`testapp`" name="`/`" dev="`tmpfs`" ino=1
scontext=system_u:system_r:testapp_t:s0
tcontext=system_u:object_r:var_run_t:s0 tclass=dir permissive=1```

We see that testapp was denied "`write open`", "`create`", and
"`add_name`" on "`/run/testapp.pid`". So our system is secure enough
that our basic policy is not even allowing the application to make a pid
file on the tmpfs. That’s pretty secure, however, it seems reasonable
that we should allow this. Our app should be able to create a pid file
and other temp files as necessary.

How do we specify this?

Our policy interacts with the SELinux system through a series of
interfaces and allow statements. For interfaces, we pass our context
type information to the interface and a macro in the security server
implements a series of rules to allow a particular behaviour. This makes
creating policy easier. Allow statements can be more specific, basically
stating:

_allow *domainX* to perform *actionY* in *contextZ*_

or something similar.

There is a command called *audit2allow* and an alias *audit2why* (==
audit2allow -w) that can give us information about why an AVC occured.
It is also able to suggest policy changes we might make to allow the
behaviour identified by the AVC denial. Let’s take a look at the output
of audit2allow for our first AVC. Adding the _-R_ switch asks the
program to return suggestions for the policy change that makes use of
the currently installed interface macros.

____
IMPORTANT: This utility does a best fit analysis. The macros that are
referenced may be a less restrictive than you require. Using the -N or
using no switches will produce traditional allow statements only. See
the audit2allow manpage
____

[source,bash]
----
ausearch --message AVC --start recent --just-one | audit2allow -R
----

require \{ type var_run_t; type testapp_t; class file \{ create open
write }; }

#============= testapp_t ============== allow testapp_t var_run_t:file
\{ create open write }; files_rw_pid_dirs(testapp_t)```

Here you see one allow statement and one interface. The allow statement
says, “Any process labelled _testapp_t_ can access a _file_ labelled
_var_run_t_ for the actions _create, open, write_. The interface appears
to be for creating policy that allows read and write access to
directories used for pid files. It is being passed our testapp_t type as
a parameter.

*Where to find interface information*

The interfaces are really macros that implement allow statments and
additional macros to more easily build policy and promote reuse. The
interface definitions are provided as part of the _selinux-policy-devel_
package. This should be installed on your system already. The files for
the definitions are stored in _/usr/share/selinux/devel/include_. Like
our own policy interfaces, they are stored in files with the _*.if_
extention. The command audit2allow _-R_ looks at the interfaces that
have been built from these files to find matches. We can also search
through the files ourselves to find interfaces that we want to add to
our policy. For now let’s use the recommendation from audit2allow and
modify the testapp.te file. Open the policy with the vim editor.

[source,bash]
----
vim /root/selinuxlab/policy/testapp.te
----

It should look like the following.

policy_module(testapp, 1.0.0)

=== 

== 

== Declarations

== 

type testapp_t; type testapp_exec_t; init_daemon_domain(testapp_t,
testapp_exec_t)

permissive testapp_t;

=== 

== 

== testapp local policy

== 

allow testapp_t self:process \{ fork }; allow testapp_t self:fifo_file
rw_fifo_file_perms; allow testapp_t self:unix_stream_socket
create_stream_socket_perms;

domain_use_interactive_fds(testapp_t)

files_read_etc_files(testapp_t)

logging_send_syslog_msg(testapp_t)

miscfiles_read_localization(testapp_t)```

Use the editor to add the audit2allow recommendations to the end of the
policy file under the testapp local policy section

allow testapp_t var_run_t:file \{ create open write };
files_rw_pid_dirs(testapp_t)```

Traditionally, for readability and searching, we try to add the elements
in alphabetical order. The resulting file should look like this.

policy_module(testapp, 1.0.0)

=== 

== 

== Declarations

== 

type testapp_t; type testapp_exec_t; init_daemon_domain(testapp_t,
testapp_exec_t)

permissive testapp_t;

=== 

== 

== testapp local policy

== 

allow testapp_t self:process \{ fork }; allow testapp_t self:fifo_file
rw_fifo_file_perms; allow testapp_t self:unix_stream_socket
create_stream_socket_perms; allow testapp_t var_run_t:file \{ create
open write };

domain_use_interactive_fds(testapp_t)

files_read_etc_files(testapp_t) files_rw_pid_dirs(testapp_t)

logging_send_syslog_msg(testapp_t)

miscfiles_read_localization(testapp_t)```

OK. Ensure your file is saved and run the testapp.sh script again. To
save the file, press escape, then type :wq! and press enter.

[source,bash]
----
./testapp.sh
----

You should see the successful compilation of your policy. The output
below is truncated.

Building and Loading Policy + make -f /usr/share/selinux/devel/Makefile
testapp.pp Compiling targeted testapp module … … Wrote:
/root/selinuxlab/policy/testapp_selinux-1.0-1.el9.src.rpm Wrote:
/root/selinuxlab/policy/noarch/testapp_selinux-1.0-1.el9.noarch.rpm
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.Xm82Fg + umask 022 + cd
/root/selinuxlab/policy + /usr/bin/rm -rf
/root/selinuxlab/policy/.build/testapp_selinux-1.0-1.el9.x86_64 +
RPM_EC=0 ++ jobs -p + exit 0```

*REMINDER* Run *date +%T* just before restarting your testapp. Use the
output of the command in your ausearch command.

[source,bash]
----
TIME=`date +%T`;export TIME; sudo systemctl restart testapp; sudo ausearch --message AVC --just-one --start $TIME
----

'''''

time->Sun Oct 30 23:09:27 2022 type=PROCTITLE
msg=audit(1667171367.011:2423): proctitle="`/usr/local/sbin/testapp`"
type=SYSCALL msg=audit(1667171367.011:2423): arch=c000003e syscall=257
success=yes exit=4 a0=ffffff9c a1=4033f3 a2=0 a3=0 items=0 ppid=1
pid=152896 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0
sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="`testapp`"
exe="`/usr/local/sbin/testapp`" subj=system_u:system_r:testapp_t:s0
key=(null) type=AVC msg=audit(1667171367.011:2423): avc: denied \{ open
} for pid=152896 comm="`testapp`" path="`/proc/meminfo`" dev="`proc`"
ino=4026532024 scontext=system_u:system_r:testapp_t:s0
tcontext=system_u:object_r:proc_t:s0 tclass=file permissive=1 type=AVC
msg=audit(1667171367.011:2423): avc: denied \{ read } for pid=152896
comm="`testapp`" name="`meminfo`" dev="`proc`" ino=4026532024
scontext=system_u:system_r:testapp_t:s0
tcontext=system_u:object_r:proc_t:s0 tclass=file permissive=1```

Excellent! The previous AVC is gone!

We still have more though. Let’s dig into the interface files to find
the answer to this next one.

If we look at the AVC, we can see that the testapp process is being
denied open and read on /proc/meminfo. We need to allow our application
to look at system state information in /proc. Let’s use find to look for
interface definition files that contain /proc and something about
'`system state information`'.

[source,bash]
----
cd /usr/share/selinux/devel/include
find . -type f -name "*.if" -exec grep -H '/proc' {} \; | grep "system state information"
----

./kernel/kernel.if:## Allows caller to read system state information in
/proc.```

Wow, lucky guess ;-)

Lets look in the file and find the "`system state information`" comment.
You can use the _less_ command and then _/ read system state
information_. We find this interface definition.

[source,bash]
----
less /usr/share/selinux/devel/include/kernel/kernel.if
----

interface(`+kernel_read_system_state',+` gen_require(` attribute
kernel_system_state_reader; ’)

....
    typeattribute $1 kernel_system_state_reader;
....

’)```

The interface defined at the bottom of the file is called
*kernel_read_system_state* and it takes one required parameter that is
the context of the process that we want to be a
_kernel_system_state_reader_. That means we pass *testapp_t* to the
interface. Edit the testapp.te file with vim and add a line in
alphabetical order that calls *kernel_read_system_state(testapp_t)*

When you are done, the end of the file should look like this.

files_read_etc_files(testapp_t) files_rw_pid_dirs(testapp_t)

kernel_read_system_state(testapp_t)

logging_send_syslog_msg(testapp_t)

miscfiles_read_localization(testapp_t)```

OK. Ensure your file is saved and run the testapp.sh script again. Run
*date +%T* again to get a new time. Now, restart the testapp service.
And the moment of truth, check to see if the AVC is still there.

[source,bash]
----
TIME=`date +%T`;export TIME; sudo systemctl restart testapp; sudo ausearch --message AVC --start $TIME | grep meminfo | wc -l;
----

0``` Zero is good.

2 AVCs down and a few more to go. Let’s look at some network AVCs next.
On to the next challenge!
